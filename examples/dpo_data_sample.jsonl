{"prompt": "Write a Python function to calculate factorial.", "chosen": "Here's an efficient factorial function:\n\n```python\ndef factorial(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"Factorial is not defined for negative numbers\")\n    if n <= 1:\n        return 1\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n    return result\n```\n\nThis iterative approach has O(n) time complexity and O(1) space complexity, making it more memory-efficient than recursion for large values.", "rejected": "```python\ndef factorial(n):\n    return factorial(n-1) * n\n```\nThis calculates factorial recursively."}
{"prompt": "How do I handle exceptions in Python?", "chosen": "Python uses try-except blocks for exception handling:\n\n```python\ntry:\n    result = 10 / 0\nexcept ZeroDivisionError as e:\n    print(f\"Error: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\nelse:\n    print(\"Success\")\nfinally:\n    print(\"Cleanup code here\")\n```\n\nKey points:\n- `except` catches specific exceptions\n- `else` runs if no exception occurred\n- `finally` always runs for cleanup\n- Use specific exception types rather than bare `except`", "rejected": "Just use try except:\n```python\ntry:\n    code\nexcept:\n    pass\n```"}
{"prompt": "Implement a queue data structure in Python.", "chosen": "Here's a queue implementation using `collections.deque` for O(1) operations:\n\n```python\nfrom collections import deque\n\nclass Queue:\n    def __init__(self):\n        self._items = deque()\n    \n    def enqueue(self, item):\n        self._items.append(item)\n    \n    def dequeue(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._items.popleft()\n    \n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"Queue is empty\")\n        return self._items[0]\n    \n    def is_empty(self) -> bool:\n        return len(self._items) == 0\n    \n    def __len__(self) -> int:\n        return len(self._items)\n```\n\nUsing `deque` ensures both enqueue and dequeue are O(1) operations.", "rejected": "```python\nclass Queue:\n    def __init__(self):\n        self.items = []\n    def enqueue(self, item):\n        self.items.insert(0, item)\n    def dequeue(self):\n        return self.items.pop()\n```"}
{"prompt": "Write a function to find duplicates in a list.", "chosen": "Here's an efficient solution using a set:\n\n```python\ndef find_duplicates(lst: list) -> list:\n    seen = set()\n    duplicates = set()\n    \n    for item in lst:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    \n    return list(duplicates)\n\n# Example\nnums = [1, 2, 3, 2, 4, 3, 5]\nprint(find_duplicates(nums))  # [2, 3]\n```\n\nTime complexity: O(n), Space complexity: O(n). Using sets ensures O(1) lookup time.", "rejected": "def find_duplicates(lst):\n    duplicates = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] == lst[j] and lst[i] not in duplicates:\n                duplicates.append(lst[i])\n    return duplicates"}
{"prompt": "Explain how to use async/await in Python.", "chosen": "Async/await enables concurrent I/O-bound operations:\n\n```python\nimport asyncio\n\nasync def fetch_data(url: str) -> str:\n    print(f\"Fetching {url}\")\n    await asyncio.sleep(1)  # Simulate network delay\n    return f\"Data from {url}\"\n\nasync def main():\n    # Run tasks concurrently\n    tasks = [\n        fetch_data(\"https://api1.example.com\"),\n        fetch_data(\"https://api2.example.com\"),\n        fetch_data(\"https://api3.example.com\")\n    ]\n    results = await asyncio.gather(*tasks)\n    print(results)\n\n# Run the event loop\nasyncio.run(main())\n```\n\nKey concepts:\n- `async def` defines a coroutine\n- `await` pauses execution until the awaited task completes\n- `asyncio.gather()` runs multiple coroutines concurrently\n- Best for I/O-bound tasks (network, file operations)", "rejected": "async await is for asynchronous programming. Use async before def and await before function calls."}
